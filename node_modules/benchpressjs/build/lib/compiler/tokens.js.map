{"version":3,"sources":["../../../lib/compiler/tokens.js"],"names":["_","require","first","arr","fn","l","length","i","res","exports","splitArgs","str","out","inString","currentArg","index","c","push","trim","Token","constructor","tokenType","name","priority","Text","value","Expression","found","extensions","Ext","matches","patterns","pattern","match","TypeError","Extension","flatMap","map","join","unescapeMap","StringLiteral","raw","rawValue","replace","Object","assign","SimpleExpression","path","simpleOrString","HelperExpression","helperName","args","arg","OpenIf","not","test","OpenIter","subject","cleanName","Else","Close","RawMustache","expression","EscapedMustache","tokens"],"mappings":"AAAA;;AAEA,MAAMA,IAAIC,QAAQ,QAAR,CAAV;;AAEA;;;;;AAKA,SAASC,KAAT,CAAeC,GAAf,EAAoBC,EAApB,EAAwB;AACtB,QAAMC,IAAIF,IAAIG,MAAd;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIF,CAApB,EAAuBE,KAAK,CAA5B,EAA+B;AAC7B,UAAMC,MAAMJ,GAAGD,IAAII,CAAJ,CAAH,EAAWA,CAAX,CAAZ;AACA,QAAIC,GAAJ,EAAS;AACP,aAAOA,GAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD;AACDC,QAAQP,KAAR,GAAgBA,KAAhB;;AAEA;;;;AAIA,SAASQ,SAAT,CAAmBC,GAAnB,EAAwB;AACtB,QAAMC,MAAM,EAAZ;;AAEA,MAAIC,WAAW,KAAf;AACA,MAAIC,aAAa,EAAjB;;AAEA,OAAK,IAAIC,QAAQ,CAAjB,EAAoBA,QAAQJ,IAAIL,MAAhC,EAAwCS,SAAS,CAAjD,EAAoD;AAClD,UAAMC,IAAIL,IAAII,KAAJ,CAAV;AACA,QAAIC,MAAM,GAAN,IAAa,CAACH,QAAlB,EAA4B;AAC1BD,UAAIK,IAAJ,CAASH,WAAWI,IAAX,EAAT;AACAJ,mBAAa,EAAb;AACD,KAHD,MAGO,IAAIA,WAAWR,MAAX,KAAsB,CAAtB,IAA2BU,MAAM,GAAjC,IAAwC,CAACH,QAA7C,EAAuD;AAC5DC,oBAAcE,CAAd;AACAH,iBAAW,IAAX;AACD,KAHM,MAGA,IAAIA,YAAYG,MAAM,GAAlB,IAAyBL,IAAII,QAAQ,CAAZ,MAAmB,IAAhD,EAAsD;AAC3DD,oBAAcE,CAAd;AACAH,iBAAW,KAAX;AACD,KAHM,MAGA,IAAI,EAAEG,MAAM,GAAN,IAAaF,WAAWR,MAAX,KAAsB,CAArC,CAAJ,EAA6C;AAClDQ,oBAAcE,CAAd;AACD;AACF;AACDJ,MAAIK,IAAJ,CAASH,WAAWI,IAAX,EAAT;;AAEA,SAAON,GAAP;AACD;AACDH,QAAQC,SAAR,GAAoBA,SAApB;;AAEA,MAAMS,KAAN,CAAY;AACVC,gBAAc;AACZ,SAAKC,SAAL,GAAiB,KAAKD,WAAL,CAAiBE,IAAlC;AACD;;AAHS;;AAANH,K,CAKGI,Q,GAAW,C;AAGpB,MAAMC,IAAN,SAAmBL,KAAnB,CAAyB;AACvBC,cAAYK,KAAZ,EAAmB;AACjB;AACA,SAAKA,KAAL,GAAaA,KAAb;AACD;AAJsB;;AAOzB,MAAMC,UAAN,SAAyBP,KAAzB,CAA+B;AAC7BC,cAAYK,KAAZ,EAAmB;AACjB;;AAEA,UAAME,QAAQzB,MAAMwB,WAAWE,UAAjB,EAA8BC,GAAD,IAAS;AAClD,UAAIC,OAAJ;AACA,UAAID,IAAIE,QAAR,EAAkB;AAChBD,kBAAU5B,MAAM2B,IAAIE,QAAV,EAAoBC,WAAWP,MAAMQ,KAAN,CAAa,OAAMD,OAAQ,IAA3B,CAA/B,CAAV;AACD,OAFD,MAEO;AACLF,kBAAUL,MAAMQ,KAAN,CAAa,OAAMJ,IAAIG,OAAQ,IAA/B,CAAV;AACD;AACD,aAAOF,WAAW,CAACD,GAAD,EAAMC,OAAN,CAAlB;AACD,KARa,CAAd;;AAUA,QAAI,CAACH,KAAL,EAAY;AACV,YAAMO,UAAU,mBAAV,CAAN;AACD;;AAED,UAAM,CAACC,SAAD,EAAYL,OAAZ,IAAuBH,KAA7B;AACA,WAAO,IAAIQ,SAAJ,CAAc,GAAGL,OAAjB,CAAP;AACD;;AAGD,aAAWE,OAAX,GAAqB;AACnB,WAAOhC,EAAEoC,OAAF,CAAUV,WAAWE,UAArB,EAAiCC,OAAOA,IAAIE,QAAJ,IAAgBF,IAAIG,OAA5D,EACJK,GADI,CACAL,WAAY,MAAKA,OAAQ,GADzB,EAEJM,IAFI,CAEC,GAFD,CAAP;AAGD;AA3B4B;;AAAzBZ,U,CAsBGE,U,GAAa,E;AAQtB,MAAMW,cAAc;AAClB,SAAO,IADW;AAElB,SAAO,IAFW;AAGlB,SAAO,IAHW;AAIlB,SAAO,IAJW;AAKlB,SAAO,IALW;AAMlB,SAAO,IANW;AAOlB,SAAO,GAPW;AAQlB,UAAQ,IARU;AASlB,UAAQ;AATU,CAApB;;AAYA,MAAMC,aAAN,SAA4BrB,KAA5B,CAAkC;AAChCC,cAAYqB,GAAZ,EAAiBC,QAAjB,EAA2B;AACzB;;AAEA,UAAMjB,QAAQiB,SAASC,OAAT,CAAiB,QAAjB,EAA2B,CAAChC,GAAD,EAAMK,CAAN,KAAYuB,YAAY5B,GAAZ,KAAoBK,CAA3D,CAAd;AACA4B,WAAOC,MAAP,CAAc,IAAd,EAAoB,EAAEJ,GAAF,EAAOC,QAAP,EAAiBjB,KAAjB,EAApB;AACD;;AAN+B;;AAA5Be,a,CAQGR,O,GAAU,wB;AAGnBN,WAAWE,UAAX,CAAsBX,IAAtB,CAA2BuB,aAA3B;;AAEA,MAAMM,gBAAN,SAA+B3B,KAA/B,CAAqC;AACnCC,cAAY2B,IAAZ,EAAkB;AAChB;AACAH,WAAOC,MAAP,CAAc,IAAd,EAAoB,EAAEE,IAAF,EAApB;AACD;;AAJkC;;AAA/BD,gB,CAMGd,O,GAAU,sB;AAGnBN,WAAWE,UAAX,CAAsBX,IAAtB,CAA2B6B,gBAA3B;;AAEA,MAAME,iBAAkB,MAAKR,cAAcR,OAAQ,IAAGc,iBAAiBd,OAAQ,GAA/E;;AAEA,MAAMiB,gBAAN,SAA+B9B,KAA/B,CAAqC;AACnCC,cAAYqB,GAAZ,EAAiBS,UAAjB,EAA6BC,IAA7B,EAAmC;AACjC;AACA,QAAIA,IAAJ,EAAU;AACR,YAAMhD,MAAMO,UAAUyC,KAAKR,OAAL,CAAa,QAAb,EAAuB,EAAvB,CAAV,EAAsCN,GAAtC,CAA0Ce,OAAO,IAAI1B,UAAJ,CAAe0B,GAAf,CAAjD,CAAZ;AACAR,aAAOC,MAAP,CAAc,IAAd,EAAoB,EAAEJ,GAAF,EAAOS,UAAP,EAAmBC,MAAMhD,GAAzB,EAApB;AACD,KAHD,MAGO;AACLyC,aAAOC,MAAP,CAAc,IAAd,EAAoB,EAAEJ,GAAF,EAAOS,UAAP,EAAmBC,MAAM,EAAzB,EAApB;AACD;AACF;;AATkC;;AAA/BF,gB,CAWGlB,Q,GAAW,CACf,eAAce,iBAAiBd,OAAQ,aAAYgB,cAAe,KADnD,EAEf,IAAGF,iBAAiBd,OAAQ,aAAYgB,cAAe,WAAUA,cAAe,YAFjE,C;AAMpBtB,WAAWE,UAAX,CAAsBX,IAAtB,CAA2BgC,gBAA3B;;AAEA,MAAMI,MAAN,SAAqBlC,KAArB,CAA2B;AACzBC,cAAYqB,GAAZ,EAAiBa,GAAjB,EAAsBC,IAAtB,EAA4B;AAC1B;AACAX,WAAOC,MAAP,CAAc,IAAd,EAAoB,EAAEJ,GAAF,EAAOa,KAAK,CAAC,CAACA,GAAd,EAAmBC,MAAM,IAAI7B,UAAJ,CAAe6B,IAAf,CAAzB,EAApB;AACD;;AAJwB;;AAArBF,M,CAMGtB,Q,GAAW,CACf,gBAAeL,WAAWM,OAAQ,OADnB,EAEf,gBAAeN,WAAWM,OAAQ,QAFnB,C;AANdqB,M,CAUG9B,Q,GAAW,E;AAGpB,MAAMiC,QAAN,SAAuBrC,KAAvB,CAA6B;AAC3BC,cAAYqB,GAAZ,EAAiBgB,OAAjB,EAA0B;AACxB;AACAb,WAAOC,MAAP,CAAc,IAAd,EAAoB;AAClBJ,SADkB;AAElBgB,eAAS,IAAIX,gBAAJ,CAAqBW,OAArB,CAFS;AAGlBnC,YAAMmC,QAAQd,OAAR,CAAgB,QAAhB,EAA0B,EAA1B,CAHY;AAIlBe,iBAAWD,QAAQd,OAAR,CAAgB,QAAhB,EAA0B,EAA1B,EAA8BA,OAA9B,CAAsC,8BAAtC,EAAsE,GAAtE;AAJO,KAApB;AAMD;;AAT0B;;AAAvBa,Q,CAWGzB,Q,GAAW,CACf,eAAce,iBAAiBd,OAAQ,OADxB,EAEf,cAAac,iBAAiBd,OAAQ,QAFvB,C;AAXdwB,Q,CAeGjC,Q,GAAW,E;AAGpB,MAAMoC,IAAN,SAAmBxC,KAAnB,CAAyB;;AAAnBwC,I,CACG5B,Q,GAAW,CAChB,eADgB,EAEhB,gBAFgB,C;AADd4B,I,CAKGpC,Q,GAAW,E;AAGpB,MAAMqC,KAAN,SAAoBzC,KAApB,CAA0B;AACxBC,cAAYqB,GAAZ,EAAiB;AACf;AACAG,WAAOC,MAAP,CAAc,IAAd,EAAoB,EAAEJ,GAAF,EAApB;AACD;;AAJuB;;AAApBmB,K,CAMG7B,Q,GAAW,CAChB,mBADgB,EAEhB,eAFgB,C;AANd6B,K,CAUGrC,Q,GAAW,E;AAGpB,MAAMsC,WAAN,SAA0B1C,KAA1B,CAAgC;AAC9BC,cAAYqB,GAAZ,EAAiBqB,UAAjB,EAA6B;AAC3B;AACAlB,WAAOC,MAAP,CAAc,IAAd,EAAoB,EAAEJ,GAAF,EAAOqB,YAAY,IAAIpC,UAAJ,CAAeoC,UAAf,CAAnB,EAApB;AACD;;AAJ6B;;AAA1BD,W,CAMG7B,O,GAAW,UAASN,WAAWM,OAAQ,S;AAN1C6B,W,CAOGtC,Q,GAAW,E;AAGpB,MAAMwC,eAAN,SAA8B5C,KAA9B,CAAoC;AAClCC,cAAYqB,GAAZ,EAAiBqB,UAAjB,EAA6B;AAC3B;AACAlB,WAAOC,MAAP,CAAc,IAAd,EAAoB,EAAEJ,GAAF,EAAOqB,YAAY,IAAIpC,UAAJ,CAAeoC,UAAf,CAAnB,EAApB;AACD;;AAJiC;;AAA9BC,e,CAMG/B,O,GAAW,OAAMN,WAAWM,OAAQ,M;AANvC+B,e,CAOGxC,Q,GAAW,E;AAGpB,MAAMyC,SAAS;AACb7C,OADa;AAEbK,MAFa;AAGbgB,eAHa;AAIbd,YAJa;AAKboB,kBALa;AAMbG,kBANa;AAObI,QAPa;AAQbG,UARa;AASbG,MATa;AAUbC,OAVa;AAWbC,aAXa;AAYbE;AAZa,CAAf;;AAeAtD,QAAQuD,MAAR,GAAiBA,MAAjB","file":"tokens.js","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\n/**\n * Get the first truthy value returned by a mapper function\n * @param {any[]} arr\n * @param {function} fn\n */\nfunction first(arr, fn) {\n  const l = arr.length;\n  for (let i = 0; i < l; i += 1) {\n    const res = fn(arr[i], i);\n    if (res) {\n      return res;\n    }\n  }\n\n  return null;\n}\nexports.first = first;\n\n/**\n * Split on commas, but ignore commas inside strings\n * @param {string} str\n */\nfunction splitArgs(str) {\n  const out = [];\n\n  let inString = false;\n  let currentArg = '';\n\n  for (let index = 0; index < str.length; index += 1) {\n    const c = str[index];\n    if (c === ',' && !inString) {\n      out.push(currentArg.trim());\n      currentArg = '';\n    } else if (currentArg.length === 0 && c === '\"' && !inString) {\n      currentArg += c;\n      inString = true;\n    } else if (inString && c === '\"' && str[index - 1] !== '\\\\') {\n      currentArg += c;\n      inString = false;\n    } else if (!(c === ' ' && currentArg.length === 0)) {\n      currentArg += c;\n    }\n  }\n  out.push(currentArg.trim());\n\n  return out;\n}\nexports.splitArgs = splitArgs;\n\nclass Token {\n  constructor() {\n    this.tokenType = this.constructor.name;\n  }\n\n  static priority = 0;\n}\n\nclass Text extends Token {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\nclass Expression extends Token {\n  constructor(value) {\n    super();\n\n    const found = first(Expression.extensions, (Ext) => {\n      let matches;\n      if (Ext.patterns) {\n        matches = first(Ext.patterns, pattern => value.match(`^(?:${pattern})$`));\n      } else {\n        matches = value.match(`^(?:${Ext.pattern})$`);\n      }\n      return matches && [Ext, matches];\n    });\n\n    if (!found) {\n      throw TypeError('Invalid arguments');\n    }\n\n    const [Extension, matches] = found;\n    return new Extension(...matches);\n  }\n\n  static extensions = [];\n  static get pattern() {\n    return _.flatMap(Expression.extensions, Ext => Ext.patterns || Ext.pattern)\n      .map(pattern => `(?:${pattern})`)\n      .join('|');\n  }\n}\n\nconst unescapeMap = {\n  '\\\\b': '\\b',\n  '\\\\t': '\\t',\n  '\\\\n': '\\n',\n  '\\\\v': '\\v',\n  '\\\\f': '\\f',\n  '\\\\r': '\\r',\n  '\\\\\"': '\"',\n  '\\\\\\'': '\\'',\n  '\\\\\\\\': '\\\\',\n};\n\nclass StringLiteral extends Token {\n  constructor(raw, rawValue) {\n    super();\n\n    const value = rawValue.replace(/\\\\(.)/g, (str, c) => unescapeMap[str] || c);\n    Object.assign(this, { raw, rawValue, value });\n  }\n\n  static pattern = '\"((?:\\\\\\\\.|[^\"\\\\n])*)\"';\n}\n\nExpression.extensions.push(StringLiteral);\n\nclass SimpleExpression extends Token {\n  constructor(path) {\n    super();\n    Object.assign(this, { path });\n  }\n\n  static pattern = '[@a-zA-Z0-9/._:\\\\-]+';\n}\n\nExpression.extensions.push(SimpleExpression);\n\nconst simpleOrString = `(?:${StringLiteral.pattern}|${SimpleExpression.pattern})`;\n\nclass HelperExpression extends Token {\n  constructor(raw, helperName, args) {\n    super();\n    if (args) {\n      const arr = splitArgs(args.replace(/^ *, */, '')).map(arg => new Expression(arg));\n      Object.assign(this, { raw, helperName, args: arr });\n    } else {\n      Object.assign(this, { raw, helperName, args: [] });\n    }\n  }\n\n  static patterns = [\n    `function\\\\.(${SimpleExpression.pattern})((?: *, *${simpleOrString})*)`,\n    `(${SimpleExpression.pattern})(?:\\\\( *(${simpleOrString}(?: *, *${simpleOrString})*)? *\\\\))`,\n  ];\n}\n\nExpression.extensions.push(HelperExpression);\n\nclass OpenIf extends Token {\n  constructor(raw, not, test) {\n    super();\n    Object.assign(this, { raw, not: !!not, test: new Expression(test) });\n  }\n\n  static patterns = [\n    `<!-- IF (!?)(${Expression.pattern}) -->`,\n    `{{{ ?if (!?)(${Expression.pattern}) ?}}}`,\n  ];\n  static priority = 60;\n}\n\nclass OpenIter extends Token {\n  constructor(raw, subject) {\n    super();\n    Object.assign(this, {\n      raw,\n      subject: new SimpleExpression(subject),\n      name: subject.replace(/^[./]*/, ''),\n      cleanName: subject.replace(/^[./]*/, '').replace(/(^[^a-zA-Z_])|[^a-zA-Z0-9_]/g, '_'),\n    });\n  }\n\n  static patterns = [\n    `<!-- BEGIN (${SimpleExpression.pattern}) -->`,\n    `{{{ ?each (${SimpleExpression.pattern}) ?}}}`,\n  ];\n  static priority = 50;\n}\n\nclass Else extends Token {\n  static patterns = [\n    '<!-- ELSE -->',\n    '{{{ ?else ?}}}',\n  ];\n  static priority = 40;\n}\n\nclass Close extends Token {\n  constructor(raw) {\n    super();\n    Object.assign(this, { raw });\n  }\n\n  static patterns = [\n    '<!-- END(.*?) -->',\n    '{{{ ?end ?}}}',\n  ];\n  static priority = 30;\n}\n\nclass RawMustache extends Token {\n  constructor(raw, expression) {\n    super();\n    Object.assign(this, { raw, expression: new Expression(expression) });\n  }\n\n  static pattern = `\\\\{\\\\{(${Expression.pattern})\\\\}\\\\}`;\n  static priority = 20;\n}\n\nclass EscapedMustache extends Token {\n  constructor(raw, expression) {\n    super();\n    Object.assign(this, { raw, expression: new Expression(expression) });\n  }\n\n  static pattern = `\\\\{(${Expression.pattern})\\\\}`;\n  static priority = 10;\n}\n\nconst tokens = {\n  Token,\n  Text,\n  StringLiteral,\n  Expression,\n  SimpleExpression,\n  HelperExpression,\n  OpenIf,\n  OpenIter,\n  Else,\n  Close,\n  RawMustache,\n  EscapedMustache,\n};\n\nexports.tokens = tokens;\n"]}